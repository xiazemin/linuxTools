\(注意:以下将会假定你对 RFC-793所描述的TCP熟悉. 如果不熟, 以下描述以及tcpdump程序可能对你帮助不大.\(nt:警告可忽略,

只需继续看, 不熟悉的地方可回头再看.\).





通常tcpdump对tcp数据包的显示格式如下:

src &gt; dst: flags data-seqno ack window urgent options



src 和 dst 是源和目的IP地址以及相应的端口. flags 标志由S\(SYN\), F\(FIN\), P\(PUSH, R\(RST\),

W\(ECN CWT\(nt \| rep:未知, 需补充\)\)或者 E\(ECN-Echo\(nt \| rep:未知,　需补充\)\)组成,

单独一个'.'表示没有flags标识. 数据段顺序号\(Data-seqno\)描述了此包中数据所对应序列号空间中的一个位置\(nt:整个数据被分段,

每段有一个顺序号, 所有的顺序号构成一个序列号空间\)\(可参考以下例子\). Ack 描述的是同一个连接,同一个方向,下一个本端应该接收的

\(对方应该发送的\)数据片段的顺序号. Window是本端可用的数据接收缓冲区的大小\(也是对方发送数据时需根据这个大小来组织数据\).

Urg\(urgent\) 表示数据包中有紧急的数据. options 描述了tcp的一些选项, 这些选项都用尖括号来表示\(如 &lt;mss 1024&gt;\).



src, dst 和 flags 这三个域总是会被显示. 其他域的显示与否依赖于tcp协议头里的信息.



这是一个从trsg到csam的一个rlogin应用登录的开始阶段.

rtsg.1023 &gt; csam.login: S 768512:768512\(0\) win 4096 &lt;mss 1024&gt;

csam.login &gt; rtsg.1023: S 947648:947648\(0\) ack 768513 win 4096 &lt;mss 1024&gt;

rtsg.1023 &gt; csam.login: . ack 1 win 4096

rtsg.1023 &gt; csam.login: P 1:2\(1\) ack 1 win 4096

csam.login &gt; rtsg.1023: . ack 2 win 4096

rtsg.1023 &gt; csam.login: P 2:21\(19\) ack 1 win 4096

csam.login &gt; rtsg.1023: P 1:2\(1\) ack 21 win 4077

csam.login &gt; rtsg.1023: P 2:3\(1\) ack 21 win 4077 urg 1

csam.login &gt; rtsg.1023: P 3:4\(1\) ack 21 win 4077 urg 1

第一行表示有一个数据包从rtsg主机的tcp端口1023发送到了csam主机的tcp端口login上\(nt:udp协议的端口和tcp协议的端

口是分别的两个空间, 虽然取值范围一致\). S表示设置了SYN标志. 包的顺序号是768512, 并且没有包含数据.\(表示格式

为:'first:last\(nbytes\)', 其含义是'此包中数据的顺序号从first开始直到last结束，不包括last. 并且总共包含nbytes的

用户数据'.\) 没有捎带应答\(nt:从下文来看，第二行才是有捎带应答的数据包\), 可用的接受窗口的大小为4096bytes, 并且请求端\(rtsg\)

的最大可接受的数据段大小是1024字节\(nt:这个信息作为请求发向应答端csam, 以便双方进一步的协商\).



Csam 向rtsg 回复了基本相同的SYN数据包, 其区别只是多了一个' piggy-backed ack'\(nt:捎带回的ack应答, 针对rtsg的SYN数据包\).



rtsg 同样针对csam的SYN数据包回复了一ACK数据包作为应答. '.'的含义就是此包中没有标志被设置. 由于此应答包中不含有数据, 所以

包中也没有数据段序列号. 提醒! 此ACK数据包的顺序号只是一个小整数1. 有如下解释:tcpdump对于一个tcp连接上的会话, 只打印会话两端的

初始数据包的序列号,其后相应数据包只打印出与初始包序列号的差异.即初始序列号之后的序列号,　可被看作此会话上当前所传数据片段在整个

要传输的数据中的'相对字节'位置\(nt:双方的第一个位置都是1, 即'相对字节'的开始编号\).　'-Ｓ'将覆盖这个功能,　

使数据包的原始顺序号被打印出来.



 



第六行的含义为:rtsg 向 csam发送了19字节的数据\(字节的编号为2到20，传送方向为rtsg到csam\). 包中设置了PUSH标志. 在第7行,

csam 喊到， 她已经从rtsg中收到了21以下的字节, 但不包括21编号的字节. 这些字节存放在csam的socket的接收缓冲中, 相应地,

csam的接收缓冲窗口大小会减少19字节\(nt:可以从第5行和第7行win属性值的变化看出来\). csam在第7行这个包中也向rtsg发送了一个

字节. 在第8行和第9行, csam 继续向rtsg 分别发送了两个只包含一个字节的数据包, 并且这个数据包带PUSH标志.



如果所抓到的tcp包\(nt:即这里的snapshot\)太小了，以至tcpdump无法完整得到其头部数据, 这时, tcpdump会尽量解析这个不完整的头,

并把剩下不能解析的部分显示为'\[\|tcp\]'. 如果头部含有虚假的属性信息\(比如其长度属性其实比头部实际长度长或短\), tcpdump会为该头部

显示'\[bad opt\]'. 如果头部的长度告诉我们某些选项\(nt \| rt:从下文来看， 指tcp包的头部中针对ip包的一些选项, 回头再翻\)会在此包中,

而真正的IP\(数据包的长度又不够容纳这些选项, tcpdump会显示'\[bad hdr length\]'.





抓取带有特殊标志的的TCP包\(如SYN-ACK标志, URG-ACK标志等\).



在TCP的头部中, 有8比特\(bit\)用作控制位区域, 其取值为:

CWR \| ECE \| URG \| ACK \| PSH \| RST \| SYN \| FIN

\(nt \| rt:从表达方式上可推断:这8个位是用或的方式来组合的, 可回头再翻\)



现假设我们想要监控建立一个TCP连接整个过程中所产生的数据包. 可回忆如下:TCP使用3次握手协议来建立一个新的连接; 其与此三次握手

连接顺序对应，并带有相应TCP控制标志的数据包如下:

1\) 连接发起方\(nt:Caller\)发送SYN标志的数据包

2\) 接收方\(nt:Recipient\)用带有SYN和ACK标志的数据包进行回应

3\) 发起方收到接收方回应后再发送带有ACK标志的数据包进行回应





0 15 31

-----------------------------------------------------------------

\| source port \| destination port \|

-----------------------------------------------------------------

\| sequence number \|

-----------------------------------------------------------------

\| acknowledgment number \|

-----------------------------------------------------------------

\| HL \| rsvd \|C\|E\|U\|A\|P\|R\|S\|F\| window size \|

-----------------------------------------------------------------

\| TCP checksum \| urgent pointer \|

-----------------------------------------------------------------



一个TCP头部,在不包含选项数据的情况下通常占用20个字节\(nt \| rt:options 理解为选项数据，需回译\). 第一行包含0到3编号的字节,

第二行包含编号4-7的字节.



如果编号从0开始算, TCP控制标志位于13字节\(nt:第四行左半部分\).



 



0 7\| 15\| 23\| 31

----------------\|---------------\|---------------\|----------------

\| HL \| rsvd \|C\|E\|U\|A\|P\|R\|S\|F\| window size \|

----------------\|---------------\|---------------\|----------------

\| \| 13th octet \| \| \|



让我们仔细看看编号13的字节:



\| \|

\|---------------\|

\|C\|E\|U\|A\|P\|R\|S\|F\|

\|---------------\|

\|7 5 3 0\|





这里有我们感兴趣的控制标志位. 从右往左这些位被依次编号为0到7, 从而 PSH位在3号, 而URG位在5号.



 



提醒一下自己, 我们只是要得到包含SYN标志的数据包. 让我们看看在一个包的包头中, 如果SYN位被设置, 到底

在13号字节发生了什么:



\|C\|E\|U\|A\|P\|R\|S\|F\|

\|---------------\|

\|0 0 0 0 0 0 1 0\|

\|---------------\|

\|7 6 5 4 3 2 1 0\|





在控制段的数据中, 只有比特1\(bit number 1\)被置位.



假设编号为13的字节是一个8位的无符号字符型,并且按照网络字节号排序\(nt:对于一个字节来说，网络字节序等同于主机字节序\), 其二进制值

如下所示:

00000010



并且其10进制值为:



0\*2^7 + 0\*2^6 + 0\*2^5 + 0\*2^4 + 0\*2^3 + 0\*2^2 + 1\*2^1 + 0\*2^0 = 2\(nt: 1 \* 2^6 表示1乘以2的6次方, 也许这样更

清楚些, 即把原来表达中的指数7 6 ... 0挪到了下面来表达\)



接近目标了, 因为我们已经知道, 如果数据包头部中的SYN被置位, 那么头部中的第13个字节的值为2\(nt: 按照网络序, 即大头方式, 最重要的字节

在前面\(在前面,即该字节实际内存地址比较小, 最重要的字节,指数学表示中数的高位, 如356中的3\) \).



表达为tcpdump能理解的关系式就是:

tcp\[13\] 2



从而我们可以把此关系式当作tcpdump的过滤条件, 目标就是监控只含有SYN标志的数据包:

tcpdump -i xl0 tcp\[13\] 2 \(nt: xl0 指网络接口, 如eth0\)



这个表达式是说"让TCP数据包的第13个字节拥有值2吧", 这也是我们想要的结果.





现在, 假设我们需要抓取带SYN标志的数据包, 而忽略它是否包含其他标志.\(nt:只要带SYN就是我们想要的\). 让我们来看看当一个含有

SYN-ACK的数据包\(nt:SYN 和 ACK 标志都有\), 来到时发生了什么:

\|C\|E\|U\|A\|P\|R\|S\|F\|

\|---------------\|

\|0 0 0 1 0 0 1 0\|

\|---------------\|

\|7 6 5 4 3 2 1 0\|



13号字节的1号和4号位被置位, 其二进制的值为:

00010010



转换成十进制就是:



0\*2^7 + 0\*2^6 + 0\*2^5 + 1\*2^4 + 0\*2^3 + 0\*2^2 + 1\*2^1 + 0\*2 = 18\(nt: 1 \* 2^6 表示1乘以2的6次方, 也许这样更

清楚些, 即把原来表达中的指数7 6 ... 0挪到了下面来表达\)



现在, 却不能只用'tcp\[13\] 18'作为tcpdump的过滤表达式, 因为这将导致只选择含有SYN-ACK标志的数据包, 其他的都被丢弃.

提醒一下自己, 我们的目标是: 只要包的SYN标志被设置就行, 其他的标志我们不理会.



为了达到我们的目标, 我们需要把13号字节的二进制值与其他的一个数做AND操作\(nt:逻辑与\)来得到SYN比特位的值. 目标是:只要SYN 被设置

就行, 于是我们就把她与上13号字节的SYN值\(nt: 00000010\).



00010010 SYN-ACK 00000010 SYN

AND 00000010 \(we want SYN\) AND 00000010 \(we want SYN\)

-------- --------

= 00000010 = 00000010



我们可以发现, 不管包的ACK或其他标志是否被设置, 以上的AND操作都会给我们相同的值, 其10进制表达就是2\(2进制表达就是00000010\).

从而我们知道, 对于带有SYN标志的数据包, 以下的表达式的结果总是真\(true\):



\( \( value of octet 13 \) AND \( 2 \) \) \( 2 \) \(nt: value of octet 13, 即13号字节的值\)



灵感随之而来, 我们于是得到了如下的tcpdump 的过滤表达式

tcpdump -i xl0 'tcp\[13\] & 2 2'



注意, 单引号或反斜杆\(nt: 这里用的是单引号\)不能省略, 这可以防止shell对&的解释或替换.

