\(nt: 指把一个IP数据包分成多个IP数据包\)



碎片IP数据包\(nt: 即一个大的IP数据包破碎后生成的小IP数据包\)有如下两种显示格式.

\(frag id:size@offset+\)

\(frag id:size@offset\)

\(第一种格式表示, 此碎片之后还有后续碎片. 第二种格式表示, 此碎片为最后一个碎片.\)



id 表示破碎编号\(nt: 从下文来看, 会为每个要破碎的大IP包分配一个破碎编号, 以便区分每个小碎片是否由同一数据包破碎而来\).

size 表示此碎片的大小 , 不包含碎片头部数据. offset表示此碎片所含数据在原始整个IP包中的偏移\(\(nt: 从下文来看,

一个IP数据包是作为一个整体被破碎的, 包括头和数据, 而不只是数据被分割\).



每个碎片都会使tcpdump产生相应的输出打印. 第一个碎片包含了高层协议的头数据\(nt:从下文来看, 被破碎IP数据包中相应tcp头以及

IP头都放在了第一个碎片中 \), 从而tcpdump会针对第一个碎片显示这些信息, 并接着显示此碎片本身的信息. 其后的一些碎片并不包含

高层协议头信息, 从而只会在显示源和目的之后显示碎片本身的信息. 以下有一个例子: 这是一个从arizona.edu 到lbl-rtsg.arpa

途经CSNET网络\(nt: CSNET connection 可理解为建立在CSNET 网络上的连接\)的ftp应用通信片段:

arizona.ftp-data &gt; rtsg.1170: . 1024:1332\(308\) ack 1 win 4096 \(frag 595a:328@0+\)

arizona &gt; rtsg: \(frag 595a:204@328\)

rtsg.1170 &gt; arizona.ftp-data: . ack 1536 win 2560



有几点值得注意:

第一, 第二行的打印中, 地址后面没有端口号.

这是因为TCP协议信息都放到了第一个碎片中, 当显示第二个碎片时, 我们无法知道此碎片所对应TCP包的顺序号.



第二, 从第一行的信息中, 可以发现arizona需要向rtsg发送308字节的用户数据, 而事实是, 相应IP包经破碎后会总共产生512字节

数据\(第一个碎片包含308字节的数据, 第二个碎片包含204个字节的数据, 这超过了308字节\). 如果你在查找数据包的顺序号空间中的

一些空洞\(nt: hole,空洞, 指数据包之间的顺序号没有上下衔接上\), 512这个数据就足够使你迷茫一阵\(nt: 其实只要关注308就行,

不必关注破碎后的数据总量\).



一个数据包\(nt \| rt: 指IP数据包\)如果带有非IP破碎标志, 则显示时会在最后显示'\(DF\)'.\(nt: 意味着此IP包没有被破碎过\).





时间戳

tcpdump的所有输出打印行中都会默认包含时间戳信息.

时间戳信息的显示格式如下

hh:mm:ss.frac　\(nt: 小时:分钟:秒.\(nt: frac未知, 需补充\)\)

此时间戳的精度与内核时间精度一致,　反映的是内核第一次看到对应数据包的时间\(nt: saw, 即可对该数据包进行操作\).　

而数据包从物理线路传递到内核的时间, 以及内核花费在此包上的中断处理时间都没有算进来.

