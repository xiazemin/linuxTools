如果在办公地点应用了NAT，内部网所有的机器都可以访问因特网。但如何让NAT网关后面的机器能够被从外部访问？这就是重定向的来源。重定向允许外来的流量发送到NAT网关后面的机器。 



看个例子： 



rdr on tl0 proto tcp from any to any port 80 -&gt; 192.168.1.20 



这一行重定向了TCP端口80（web服务器）流量到内部网络地址192.168.1.20。因此，即使192.168.1.20在网关后面的内部网络，外部仍然能够访问它。 



上面rdr行中from any to any部分非常有用。如果你明确知道哪些地址或者子网被允许访问web服务器的80端口，你可以在这部分严格限制： 



rdr on tl0 proto tcp from 27.146.49.0/24 to any port 80 -&gt; \ 

192.168.1.20 



这样只会重定向指定的子网。注意这表明可以重定向外部不同的访问主机到网关后面不同的机器上。这非常有用。例如，如果你知道远端的用户连接上来时使用的IP地址，你可以让他们使用网关的IP地址和端口访问他们各自的桌面计算机。 



rdr on tl0 proto tcp from 27.146.49.14 to any port 80 -&gt; \ 

192.168.1.20 

rdr on tl0 proto tcp from 16.114.4.89 to any port 80 -&gt; \ 

192.168.1.22 

rdr on tl0 proto tcp from 24.2.74.178 to any port 80 -&gt; \ 

192.168.1.23 



重定向和包过滤 



注意：转换后的数据包仍然会通过过滤引擎，根据定义的过滤规则进行阻塞或者通过。唯一的例外是如果rdr规则中使用了pass关键字，会使得重定向的数据包直接通过过滤引擎。 



还要注意由于转换是在过滤之前进行，过滤引擎所看到的是在匹配rdr规则经过转换后的目标ip地址和端口的数据包。 



\* 192.0.2.1 - 因特网上的主机 

\* 24.65.1.13 - openbsd路由器的外部地址 

\* 192.168.1.5 - web服务器的内部IP地址 



重定向规则: 



rdr on tl0 proto tcp from 192.0.2.1 to 24.65.1.13 port 80 \ 

-&gt; 192.168.1.5 port 8000 



数据包在经过rdr规则前的模样： 



\* 源地址: 192.0.2.1 

\* 源端口: 4028 \(由操作系统任意选择\) 

\* 目的地址: 24.65.1.13 

\* 目的端口: 80 



数据包经过rdr规则后的模样： 



\* 源地址: 192.0.2.1 

\* 源端口: 4028 

\* 目的地址: 192.168.1.5 

\* 目的: 8000 



过滤引擎看见的IP数据包时转换发生之后的情况。 



安全隐患 



重定向确实存在安全隐患。在防火墙上开了一个允许流量进入内部网络的洞，被保护的网络安全潜在的受到了威胁！例如，如果流量被转发到了内部的web服务 器，而web服务器上允许的守护程序或者CGI脚本程序存在漏洞，则这台服务器存在会被因特网网上的入侵者攻击危险。如果入侵者控制了这台机器，就有了进 入内部网络的通道，仅仅是因为这种流量是允许通过防火墙的。 



这种风险可以通过将允许外部网络访问的系统限制在一个单独的网段中来减小。这个网段通常也被称为非军事化区域（DMZ）或者私有服务网络（PSN）。通过 这个方法，如果web服务器被控制，通过严格的过滤进出DMZ/PSN的流量，受影响的系统仅限于DMZ/PSN网段。 



重定向和反射 



通常，重定向规则是用来将因特网上到来的连接转发到一个内部网络或者局域网的私有地址。例如： 



server = 192.168.1.40 



rdr on $ext\_if proto tcp from any to $ext\_if port 80 -&gt; $server \ 

port 80 



但是，当一个重定向规则被从局域网上的客户端进行测试时，它不会正常工作。这是因为重定向规则仅适用于通过指定端口（$ext\_if,外部接口，在上面的 例子中）的数据包。从局域网上的主机连接防火墙的外部地址，并不意味着数据包会实际的通过外部接口。防火墙上的TCP/IP栈会把到来的数据包的目的地址 在通过内部接口时与它自己的IP地址或者别名进行对比检测。那样的数据包不会真的通过外部接口，栈在任何情况下也不会建立那样的通道。因而，PF永远也不 会在外部接口上看到那些数据包，过滤规则由于指定了外部接口也不会起作用。 



指定第二条针对内部接口的也达不到预想的效果。当本地的客户端连接防火墙的外部地址时，初始化的TCP握手数据包是通过内部接口到达防火墙的。重定向规则 确实起作用了，目标地址被替换成了内部服务器，数据包通过内部接口转发到了内部的服务器。但源地址没有进行转换，仍然包含的是本地客户端的IP地址，因此 服务器把它的回应直接发送给了客户端。防火墙永远收不到应答不可能返回客户端信息，客户端收到的应答不是来自它期望的源（防火墙）会被丢弃，TCP握手失 败，不能建立连接。 



当然，局域网里的客户端仍然会希望象外部客户一样透明的访问这台内部服务器。有如下的方法解决这个问题： 



水平分割 DNS 



存在这样的可能性，即配置DNS服务器使得它回答内部主机的查询和回答外部主机的查询不一样，因此内部客户端在进行名称解析时会收到内部服务器的地址。它们直接连接到内部服务器，防火墙根本不牵扯。这会降低本地流量，因为数据包不会被送到防火墙。 



将服务器移到独立的本地网络 



增加单独的网络接口卡到防火墙，把本地的服务器从和客户端同一个网段移动到专用的网段（DMZ）可以让本地客户端按照外部重定向连接的方法一样重定向。使 用单独的网段有几个优点，包括和保留的内部主机隔离增加了安全性；服务器（我们的案例中可以从因特网访问）一旦被控制，它不能直接存取本地网络因为所有的 连接都必须通过防火墙。 



TCP 代理 



一般而言，TCP代理可以在防火墙上设置，监听要转发的端口或者将内部接口上到来的连接重定向到它监听的端口。当本地客户端连接防火墙时，代理接受连接，建立到内部服务器的第二条连接，在通信双方间进行数据转发。 



简单的代理可以使用inetd（8）和nc（1）建立。下面的/etc/inetd.conf中的条目建立一个监听套接字绑定到lookback地址（127.0.0.1）和端口5000。连接被转发到服务器192.168.1.10的80端口。 





127.0.0.1:5000 stream tcp nowait nobody /usr/bin/nc nc -w \ 

20 192.168.1.10 80 



下面的重定向规则转发内部接口的80端口到代理： 



rdr on $int\_if proto tcp from $int\_net to $ext\_if port 80 -&gt; \ 

127.0.0.1 port 5000 



RDR 和 NAT 结合 



通过对内部接口增加NAT规则，上面说的转换后源地址不变的问题可以解决。 



rdr on $int\_if proto tcp from $int\_net to $ext\_if port 80 -&gt; \ 

$server 

no nat on $int\_if proto tcp from $int\_if to $int\_net 

nat on $int\_if proto tcp from $int\_net to $server port 80 -&gt; \ 

$int\_if 



这会导致由客户端发起的初始化连接在收到内部接口的返回数据包时转换回来，客户端的源ip地址被防火墙的内部接口地址代替。内部服务器会回应防火墙的内部 接口地址，在转发给本地客户端时可以反转NAT和RDR。这个结构是非常复杂的，因为它为每个反射连接产生了2个单独的状态。必须小心配置防止NAT规则 应用到了其他流量，例如连接由外部发起（通过其他的重定向）或者防火墙自己。注意上面的rdr规则会导致TCP/IP栈看到来自内部接口带有目的地址是内 部网络的数据包。 





一般而言，上面提到的解决方法可以互相替代。 

