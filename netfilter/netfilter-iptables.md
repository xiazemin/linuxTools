![](/assets/iptables.png)对于收到的每个数据包，都从“A”点进来，经过路由判决，如果是发送给本机的就经过“B”点，然后往协议栈的上层继续传递；否则，如果该数据包的目的地是不本机，那么就经过“C”点，然后顺着“E”点将该包转发出去。

对于发送的每个数据包，首先也有一个路由判决，以确定该包是从哪个接口出去，然后经过“D”点，最后也是顺着“E”点将该包发送出去。

协议栈那五个关键点A，B，C，D和E就是我们Netfilter大展拳脚的地方了。

Netfilter是Linux 2.4.x引入的一个子系统，它作为一个通用的、抽象的框架，提供一整套的hook函数的管理机制，使得诸如数据包过滤、网络地址转换\(NAT\)和基于协议类型的连接跟踪成为了可能。Netfilter在内核中位置如下图所示：

![](/assets/netfilterp.png)这幅图，很直观的反应了用户空间的iptables和内核空间的基于Netfilter的ip\_tables模块之间的关系和其通讯方式，以及Netfilter在这其中所扮演的角色。

回到前面讨论的关于协议栈那五个关键点“ABCDE”上来。Netfilter在netfilter\_ipv4.h中将这个五个点重新命了个名，

![](/assets/tables.png)在每个关键点上，有很多已经按照优先级预先注册了的回调函数\(后面再说这些函数是什么，干什么用的。有些人喜欢把这些函数称为“钩子函数”，说的是同一个东西\)埋伏在这些关键点，形成了一条链。对于每个到来的数据包会依次被那些回调函数“调戏”一番再视情况是将其放行，丢弃还是怎么滴。但是无论如何，这些回调函数最后必须向Netfilter报告一下该数据包的死活情况，因为毕竟每个数据包都是Netfilter从人家协议栈那儿借调过来给兄弟们Happy的，别个再怎么滴也总得“活要见人，死要见尸”吧。每个钩子函数最后必须向Netfilter框架返回下列几个值其中之一：

n  NF\_ACCEPT 继续正常传输数据报。这个返回值告诉 Netfilter：到目前为止，该数据包还是被接受的并且该数据包应当被递交到网络协议栈的下一个阶段。

n  NF\_DROP 丢弃该数据报，不再传输。

n  NF\_STOLEN 模块接管该数据报，告诉Netfilter“忘掉”该数据报。该回调函数将从此开始对数据包的处理，并且Netfilter应当放弃对该数据包做任何的处理。但是，这并不意味着该数据包的资源已经被释放。这个数据包以及它独自的sk\_buff数据结构仍然有效，只是回调函数从Netfilter 获取了该数据包的所有权。

n  NF\_QUEUE 对该数据报进行排队\(通常用于将数据报给用户空间的进程进行处理\)

n  NF\_REPEAT 再次调用该回调函数，应当谨慎使用这个值，以免造成死循环。

为了让我们显得更专业些，我们开始做些约定：上面提到的五个关键点后面我们就叫它们为hook点，每个hook点所注册的那些回调函数都将其称为hook函数。

Linux 2.6版内核的Netfilter目前支持IPv4、IPv6以及DECnet等协议栈，这里我们主要研究IPv4协议。关于协议类型，hook点，hook函数，优先级，通过下面这个图给大家做个详细展示：

![](/assets/prority.png)

